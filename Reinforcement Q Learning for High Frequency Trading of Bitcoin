{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "878fe04f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#virtual machine\n",
    "from google.cloud import compute_v1\n",
    "\n",
    "\n",
    "#tensorflow\n",
    "import tensorflow as tf\n",
    "from tensorflow import keras\n",
    "\n",
    "\n",
    "# Common imports\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import os\n",
    "import os.path\n",
    "import urllib\n",
    "\n",
    "# To plot pretty figures\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "5b991d2b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<HttpError 403 when requesting https://docs.googleapis.com/v1/documents/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?alt=json returned \"Google Docs API has not been used in project 894200421030 before or it is disabled. Enable it by visiting https://console.developers.google.com/apis/api/docs.googleapis.com/overview?project=894200421030 then retry. If you enabled this API recently, wait a few minutes for the action to propagate to our systems and retry.\". Details: \"[{'@type': 'type.googleapis.com/google.rpc.Help', 'links': [{'description': 'Google developers console API activation', 'url': 'https://console.developers.google.com/apis/api/docs.googleapis.com/overview?project=894200421030'}]}, {'@type': 'type.googleapis.com/google.rpc.ErrorInfo', 'reason': 'SERVICE_DISABLED', 'domain': 'googleapis.com', 'metadata': {'service': 'docs.googleapis.com', 'consumer': 'projects/894200421030'}}]\">\n"
     ]
    }
   ],
   "source": [
    "\n",
    "from __future__ import print_function\n",
    "\n",
    "import os.path\n",
    "\n",
    "from google.auth.transport.requests import Request\n",
    "from google.oauth2.credentials import Credentials\n",
    "from google_auth_oauthlib.flow import InstalledAppFlow\n",
    "from googleapiclient.discovery import build\n",
    "from googleapiclient.errors import HttpError\n",
    "\n",
    "# If modifying these scopes, delete the file token.json.\n",
    "SCOPES = ['https://www.googleapis.com/oauth2/v1/certs\"']\n",
    "\n",
    "# The ID of a sample document.\n",
    "DOCUMENT_ID = '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'\n",
    "\n",
    "\n",
    "def main():\n",
    "    \"\"\"Shows basic usage of the Docs API.\n",
    "    Prints the title of a sample document.\n",
    "    \"\"\"\n",
    "    creds = None\n",
    "    # The file token.json stores the user's access and refresh tokens, and is\n",
    "    # created automatically when the authorization flow completes for the first\n",
    "    # time.\n",
    "    if os.path.exists('token.json'):\n",
    "        creds = Credentials.from_authorized_user_file('token.json', SCOPES)\n",
    "    # If there are no (valid) credentials available, let the user log in.\n",
    "    if not creds or not creds.valid:\n",
    "        if creds and creds.expired and creds.refresh_token:\n",
    "            creds.refresh(Request())\n",
    "        else:\n",
    "            flow = InstalledAppFlow.from_client_secrets_file(\n",
    "                open(r'C:\\Users\\zsamach\\Documents\\client_secret_894200421030-tmlp7b17g86hno8f2vmj1nfegohhd804.apps.googleusercontent.com.json'), SCOPES)\n",
    "            creds = flow.run_local_server(port=0)\n",
    "        # Save the credentials for the next run\n",
    "        with open('token.json', 'w') as token:\n",
    "            token.write(creds.to_json())\n",
    "\n",
    "    try:\n",
    "        service = build('docs', 'v1', credentials=creds)\n",
    "\n",
    "        # Retrieve the documents contents from the Docs service.\n",
    "        document = service.documents().get(documentId=DOCUMENT_ID).execute()\n",
    "\n",
    "        print('The title of the document is: {}'.format(document.get('title')))\n",
    "    except HttpError as err:\n",
    "        print(err)\n",
    "\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "5669786b",
   "metadata": {},
   "outputs": [],
   "source": [
    "!set GOOGLE_APPLICATION_CREDENTIALS='C:\\Users\\zsamach\\Documents\\client_secret_894200421030-tmlp7b17g86hno8f2vmj1nfegohhd804.apps.googleusercontent.com.json'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "2b01b949",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "'GOOGLE_APPLICATION_CREDENTIALS' is not recognized as an internal or external command,\n",
      "operable program or batch file.\n"
     ]
    }
   ],
   "source": [
    "!GOOGLE_APPLICATION_CREDENTIALS"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "10c969d3",
   "metadata": {},
   "outputs": [
    {
     "ename": "DefaultCredentialsError",
     "evalue": "Your default credentials were not found. To set up Application Default Credentials, see https://cloud.google.com/docs/authentication/external/set-up-adc for more information.",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mDefaultCredentialsError\u001b[0m                   Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[7], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m networks_client \u001b[39m=\u001b[39m compute_v1\u001b[39m.\u001b[39;49mNetworksClient()\n\u001b[0;32m      2\u001b[0m \u001b[39mfor\u001b[39;00m network \u001b[39min\u001b[39;00m networks_client\u001b[39m.\u001b[39mlist(project\u001b[39m=\u001b[39m\u001b[39m'\u001b[39m\u001b[39magent-model\u001b[39m\u001b[39m'\u001b[39m):\n\u001b[0;32m      3\u001b[0m     \u001b[39mprint\u001b[39m(network)\n",
      "File \u001b[1;32mc:\\Users\\zsamach\\AppData\\Local\\anaconda3\\envs\\google_cloud_vm\\.venv\\lib\\site-packages\\google\\cloud\\compute_v1\\services\\networks\\client.py:412\u001b[0m, in \u001b[0;36mNetworksClient.__init__\u001b[1;34m(self, credentials, transport, client_options, client_info)\u001b[0m\n\u001b[0;32m    407\u001b[0m     credentials \u001b[39m=\u001b[39m google\u001b[39m.\u001b[39mauth\u001b[39m.\u001b[39m_default\u001b[39m.\u001b[39mget_api_key_credentials(\n\u001b[0;32m    408\u001b[0m         api_key_value\n\u001b[0;32m    409\u001b[0m     )\n\u001b[0;32m    411\u001b[0m Transport \u001b[39m=\u001b[39m \u001b[39mtype\u001b[39m(\u001b[39mself\u001b[39m)\u001b[39m.\u001b[39mget_transport_class(transport)\n\u001b[1;32m--> 412\u001b[0m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_transport \u001b[39m=\u001b[39m Transport(\n\u001b[0;32m    413\u001b[0m     credentials\u001b[39m=\u001b[39;49mcredentials,\n\u001b[0;32m    414\u001b[0m     credentials_file\u001b[39m=\u001b[39;49mclient_options\u001b[39m.\u001b[39;49mcredentials_file,\n\u001b[0;32m    415\u001b[0m     host\u001b[39m=\u001b[39;49mapi_endpoint,\n\u001b[0;32m    416\u001b[0m     scopes\u001b[39m=\u001b[39;49mclient_options\u001b[39m.\u001b[39;49mscopes,\n\u001b[0;32m    417\u001b[0m     client_cert_source_for_mtls\u001b[39m=\u001b[39;49mclient_cert_source_func,\n\u001b[0;32m    418\u001b[0m     quota_project_id\u001b[39m=\u001b[39;49mclient_options\u001b[39m.\u001b[39;49mquota_project_id,\n\u001b[0;32m    419\u001b[0m     client_info\u001b[39m=\u001b[39;49mclient_info,\n\u001b[0;32m    420\u001b[0m     always_use_jwt_access\u001b[39m=\u001b[39;49m\u001b[39mTrue\u001b[39;49;00m,\n\u001b[0;32m    421\u001b[0m     api_audience\u001b[39m=\u001b[39;49mclient_options\u001b[39m.\u001b[39;49mapi_audience,\n\u001b[0;32m    422\u001b[0m )\n",
      "File \u001b[1;32mc:\\Users\\zsamach\\AppData\\Local\\anaconda3\\envs\\google_cloud_vm\\.venv\\lib\\site-packages\\google\\cloud\\compute_v1\\services\\networks\\transports\\rest.py:476\u001b[0m, in \u001b[0;36mNetworksRestTransport.__init__\u001b[1;34m(self, host, credentials, credentials_file, scopes, client_cert_source_for_mtls, quota_project_id, client_info, always_use_jwt_access, url_scheme, interceptor, api_audience)\u001b[0m\n\u001b[0;32m    472\u001b[0m url_match_items \u001b[39m=\u001b[39m maybe_url_match\u001b[39m.\u001b[39mgroupdict()\n\u001b[0;32m    474\u001b[0m host \u001b[39m=\u001b[39m \u001b[39mf\u001b[39m\u001b[39m\"\u001b[39m\u001b[39m{\u001b[39;00murl_scheme\u001b[39m}\u001b[39;00m\u001b[39m://\u001b[39m\u001b[39m{\u001b[39;00mhost\u001b[39m}\u001b[39;00m\u001b[39m\"\u001b[39m \u001b[39mif\u001b[39;00m \u001b[39mnot\u001b[39;00m url_match_items[\u001b[39m\"\u001b[39m\u001b[39mscheme\u001b[39m\u001b[39m\"\u001b[39m] \u001b[39melse\u001b[39;00m host\n\u001b[1;32m--> 476\u001b[0m \u001b[39msuper\u001b[39;49m()\u001b[39m.\u001b[39;49m\u001b[39m__init__\u001b[39;49m(\n\u001b[0;32m    477\u001b[0m     host\u001b[39m=\u001b[39;49mhost,\n\u001b[0;32m    478\u001b[0m     credentials\u001b[39m=\u001b[39;49mcredentials,\n\u001b[0;32m    479\u001b[0m     client_info\u001b[39m=\u001b[39;49mclient_info,\n\u001b[0;32m    480\u001b[0m     always_use_jwt_access\u001b[39m=\u001b[39;49malways_use_jwt_access,\n\u001b[0;32m    481\u001b[0m     api_audience\u001b[39m=\u001b[39;49mapi_audience,\n\u001b[0;32m    482\u001b[0m )\n\u001b[0;32m    483\u001b[0m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_session \u001b[39m=\u001b[39m AuthorizedSession(\n\u001b[0;32m    484\u001b[0m     \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_credentials, default_host\u001b[39m=\u001b[39m\u001b[39mself\u001b[39m\u001b[39m.\u001b[39mDEFAULT_HOST\n\u001b[0;32m    485\u001b[0m )\n\u001b[0;32m    486\u001b[0m \u001b[39mif\u001b[39;00m client_cert_source_for_mtls:\n",
      "File \u001b[1;32mc:\\Users\\zsamach\\AppData\\Local\\anaconda3\\envs\\google_cloud_vm\\.venv\\lib\\site-packages\\google\\cloud\\compute_v1\\services\\networks\\transports\\base.py:102\u001b[0m, in \u001b[0;36mNetworksTransport.__init__\u001b[1;34m(self, host, credentials, credentials_file, scopes, quota_project_id, client_info, always_use_jwt_access, api_audience, **kwargs)\u001b[0m\n\u001b[0;32m     98\u001b[0m     credentials, _ \u001b[39m=\u001b[39m google\u001b[39m.\u001b[39mauth\u001b[39m.\u001b[39mload_credentials_from_file(\n\u001b[0;32m     99\u001b[0m         credentials_file, \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mscopes_kwargs, quota_project_id\u001b[39m=\u001b[39mquota_project_id\n\u001b[0;32m    100\u001b[0m     )\n\u001b[0;32m    101\u001b[0m \u001b[39melif\u001b[39;00m credentials \u001b[39mis\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[1;32m--> 102\u001b[0m     credentials, _ \u001b[39m=\u001b[39m google\u001b[39m.\u001b[39mauth\u001b[39m.\u001b[39mdefault(\n\u001b[0;32m    103\u001b[0m         \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mscopes_kwargs, quota_project_id\u001b[39m=\u001b[39mquota_project_id\n\u001b[0;32m    104\u001b[0m     )\n\u001b[0;32m    105\u001b[0m     \u001b[39m# Don't apply audience if the credentials file passed from user.\u001b[39;00m\n\u001b[0;32m    106\u001b[0m     \u001b[39mif\u001b[39;00m \u001b[39mhasattr\u001b[39m(credentials, \u001b[39m\"\u001b[39m\u001b[39mwith_gdch_audience\u001b[39m\u001b[39m\"\u001b[39m):\n",
      "File \u001b[1;32mc:\\Users\\zsamach\\AppData\\Local\\anaconda3\\envs\\google_cloud_vm\\.venv\\lib\\site-packages\\google\\auth\\_default.py:648\u001b[0m, in \u001b[0;36mdefault\u001b[1;34m(scopes, request, quota_project_id, default_scopes)\u001b[0m\n\u001b[0;32m    640\u001b[0m             _LOGGER\u001b[39m.\u001b[39mwarning(\n\u001b[0;32m    641\u001b[0m                 \u001b[39m\"\u001b[39m\u001b[39mNo project ID could be determined. Consider running \u001b[39m\u001b[39m\"\u001b[39m\n\u001b[0;32m    642\u001b[0m                 \u001b[39m\"\u001b[39m\u001b[39m`gcloud config set project` or setting the \u001b[39m\u001b[39m%s\u001b[39;00m\u001b[39m \u001b[39m\u001b[39m\"\u001b[39m\n\u001b[0;32m    643\u001b[0m                 \u001b[39m\"\u001b[39m\u001b[39menvironment variable\u001b[39m\u001b[39m\"\u001b[39m,\n\u001b[0;32m    644\u001b[0m                 environment_vars\u001b[39m.\u001b[39mPROJECT,\n\u001b[0;32m    645\u001b[0m             )\n\u001b[0;32m    646\u001b[0m         \u001b[39mreturn\u001b[39;00m credentials, effective_project_id\n\u001b[1;32m--> 648\u001b[0m \u001b[39mraise\u001b[39;00m exceptions\u001b[39m.\u001b[39mDefaultCredentialsError(_CLOUD_SDK_MISSING_CREDENTIALS)\n",
      "\u001b[1;31mDefaultCredentialsError\u001b[0m: Your default credentials were not found. To set up Application Default Credentials, see https://cloud.google.com/docs/authentication/external/set-up-adc for more information."
     ]
    }
   ],
   "source": [
    "networks_client = compute_v1.NetworksClient()\n",
    "for network in networks_client.list(project='agent-model'):\n",
    "    print(network)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "063b0071",
   "metadata": {},
   "outputs": [],
   "source": [
    "pip install google-cloud-compute"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5dbc5ddc",
   "metadata": {},
   "outputs": [],
   "source": [
    "pip install numpy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "86070d2b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from polygon import RESTClient"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8fa82d38",
   "metadata": {},
   "outputs": [],
   "source": [
    "from datetime import date, datetime\n",
    "from typing import Any, Optional\n",
    "import pandas as pd\n",
    "from requests.adapters import HTTPAdapter\n",
    "from urllib3.util.retry import Retry\n",
    "\n",
    "markets = ['crypto', 'stocks', 'fx']\n",
    "\n",
    "class MyRESTClient(RESTClient):\n",
    "    def __init__(self, auth_key: str='xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2', timeout:int=5):\n",
    "        super().__init__(auth_key)\n",
    "        retry_strategy = Retry(total=10,\n",
    "                               backoff_factor=10,\n",
    "                               status_forcelist=[429, 500, 502, 503, 504])\n",
    "        adapter = HTTPAdapter(max_retries=retry_strategy)\n",
    "        self._session.mount('https://', adapter)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72ccd0c0",
   "metadata": {},
   "outputs": [],
   "source": [
    "client = MyRESTClient(['xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ecf8192c",
   "metadata": {},
   "outputs": [],
   "source": [
    "class MyRESTClient(RESTClient):\n",
    "    def __init__(self, auth_key: str=['xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2'], timeout:int=5):\n",
    "        super().__init__(auth_key)\n",
    "        retry_strategy = Retry(total=10,\n",
    "                               backoff_factor=10,\n",
    "                               status_forcelist=[429, 500, 502, 503, 504])\n",
    "        adapter = HTTPAdapter(max_retries=retry_strategy)\n",
    "        self._session.mount('https://', adapter)\n",
    "\n",
    "    def get_tickers(self, market:str=None) -> pd.DataFrame:\n",
    "        if not market in markets:\n",
    "            raise Exception(f'Market must be one of {markets}.')\n",
    "\n",
    "        resp = self.reference_tickers_v3(market=market)\n",
    "        if hasattr(resp, 'results'):\n",
    "            df = pd.DataFrame(resp.results)\n",
    "\n",
    "            while hasattr(resp, 'next_url'):\n",
    "                resp = self.reference_tickers_v3(next_url=resp.next_url)\n",
    "                df = df.append(pd.DataFrame(resp.results))\n",
    "\n",
    "            if market == 'crypto':\n",
    "                # Only use USD pairings.\n",
    "                df = df[df['currency_symbol'] == 'USD']\n",
    "                df['name'] = df['base_currency_name']\n",
    "                df = df[['ticker', 'name', 'market', 'active']]\n",
    "\n",
    "            df = df.drop_duplicates(subset='ticker')\n",
    "            return df\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c388bd72",
   "metadata": {},
   "outputs": [],
   "source": [
    "client = MyRESTClient(['xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2'])\n",
    "df = client.get_tickers(market='crypto')\n",
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c1b7f224",
   "metadata": {},
   "outputs": [],
   "source": [
    "class MyRESTClient(RESTClient):\n",
    "    def __init__(self, auth_key: str=['xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2'], timeout:int=5):\n",
    "        super().__init__(auth_key)\n",
    "        retry_strategy = Retry(total=10,\n",
    "                               backoff_factor=10,\n",
    "                               status_forcelist=[429, 500, 502, 503, 504])\n",
    "        adapter = HTTPAdapter(max_retries=retry_strategy)\n",
    "        self._session.mount('https://', adapter)\n",
    "\n",
    "    def get_tickers(self, market:str=None) -> pd.DataFrame:\n",
    "        if not market in markets:\n",
    "            raise Exception(f'Market must be one of {markets}.')\n",
    "\n",
    "        resp = self.reference_tickers_v3(market=market)\n",
    "        if hasattr(resp, 'results'):\n",
    "            df = pd.DataFrame(resp.results)\n",
    "\n",
    "            while hasattr(resp, 'next_url'):\n",
    "                resp = self.reference_tickers_v3(next_url=resp.next_url)\n",
    "                df = df.append(pd.DataFrame(resp.results))\n",
    "\n",
    "            if market == 'crypto':\n",
    "                # Only use USD pairings.\n",
    "                df = df[df['currency_symbol'] == 'USD']\n",
    "                df['name'] = df['base_currency_name']\n",
    "                df = df[['ticker', 'name', 'market', 'active']]\n",
    "\n",
    "            df = df.drop_duplicates(subset='ticker')\n",
    "            return df\n",
    "        return None\n",
    "\n",
    "    def get_bars(self, market:str=None, ticker:str=None, multiplier:int=1,\n",
    "                 timespan:str='minute', from_:date=None, to:date=None) -> pd.DataFrame:\n",
    "\n",
    "        if not market in markets:\n",
    "            raise Exception(f'Market must be one of {markets}.')\n",
    "\n",
    "        if ticker is None:\n",
    "            raise Exception('Ticker must not be None.')\n",
    "\n",
    "        from_ = from_ if from_ else date(2000,1,1)\n",
    "        to = to if to else date.today()\n",
    "\n",
    "        if market == 'crypto':\n",
    "            resp = self.crypto_aggregates(ticker, multiplier, timespan,\n",
    "                                          from_.strftime('%Y-%m-%d'), to.strftime('%Y-%m-%d'),\n",
    "                                          limit=50000)\n",
    "            df = pd.DataFrame(resp.results)\n",
    "            last_minute = 0\n",
    "            while resp.results[-1]['t'] > last_minute:\n",
    "                last_minute = resp.results[-1]['t'] # Last minute in response\n",
    "                last_minute_date = datetime.fromtimestamp(last_minute/1000).strftime('%Y-%m-%d')\n",
    "                resp = self.crypto_aggregates(ticker, multiplier, timespan,\n",
    "                                          last_minute_date, to.strftime('%Y-%m-%d'),\n",
    "                                          limit=50000)\n",
    "                new_bars = pd.DataFrame(resp.results)\n",
    "                df = df.append(new_bars[new_bars['t'] > last_minute])\n",
    "\n",
    "            df['date'] = pd.to_datetime(df['t'], unit='ms')\n",
    "            df = df.rename(columns={'o':'open',\n",
    "                                    'h':'high',\n",
    "                                    'l':'low',\n",
    "                                    'c':'close',\n",
    "                                    'v':'volume',\n",
    "                                    'vw':'vwap',\n",
    "                                    'n':'transactions'})\n",
    "            df = df[['date','open','high','low','close','volume']]\n",
    "\n",
    "            return df\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "397bc8cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "start = datetime(2020,1,1)\n",
    "end = datetime(2022,12,1)\n",
    "client = MyRESTClient(['xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2'])\n",
    "df1 = client.get_bars(market='crypto', ticker='X:BTCUSD', from_=start,to=end)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "55b9ea74",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=df1\n",
    "\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e52d04a7",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Calculate the MACD and Signal Line indicators\n",
    "## Calculate the Short Term Exponential Moving Average\n",
    "ShortEMA = data.close.ewm(span=30, adjust=False).mean() \n",
    "## Calculate the Long Term Exponential Moving Average\n",
    "LongEMA = data.close.ewm(span=60, adjust=False).mean() \n",
    "## Calculate the Moving Average Convergence/Divergence (MACD)\n",
    "data['MACD'] = ShortEMA - LongEMA\n",
    "## Calcualte the signal line\n",
    "data['signal'] = data['MACD'].ewm(span=15, adjust=False).mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d4bfb913",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at t=0 day tenor\n",
    "\n",
    "ChangeInHigh=data.high.shift(+60)/data.close.shift(+1)\n",
    "ChangeInLow=data.close.shift(+1)/data.low.shift(+60)\n",
    "TrailingStd=data.close.shift(+1).rolling(60).std()/data.close.shift(+1).rolling(60).mean()\n",
    "HighDifferential=ChangeInHigh/TrailingStd\n",
    "LowDifferential=ChangeInLow/TrailingStd\n",
    "\n",
    "Momentum=(LowDifferential-HighDifferential)\n",
    "data['Momentum%']=Momentum/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c5dcb18c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 1 day tenor (T=1)\n",
    "\n",
    "ChangeInHighMinus_1=data.high.shift(+90)/data.close.shift(+2)\n",
    "ChangeInLowMinus_1=data.close.shift(+2)/data.low.shift(+90)\n",
    "TrailingStdMinus_1=data.close.shift(+2).rolling(60).std()/data.close.shift(+2).rolling(60).mean()\n",
    "HighDifferentialMinus_1=ChangeInHighMinus_1/TrailingStdMinus_1\n",
    "LowDifferentialMinus_1=ChangeInLowMinus_1/TrailingStdMinus_1\n",
    "\n",
    "MomentumMinus_1=(LowDifferentialMinus_1-HighDifferentialMinus_1)\n",
    "data['Momentum%Minus_1']=Momentum/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f4213049",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 2 day tenor (T=2)\n",
    "\n",
    "ChangeInHighMinus_2=data.high.shift(+120)/data.close.shift(+3)\n",
    "ChangeInLowMinus_2=data.close.shift(+3)/data.low.shift(+120)\n",
    "TrailingStdMinus_2=data.close.shift(+3).rolling(60).std()/data.close.shift(+3).rolling(60).mean()\n",
    "HighDifferentialMinus_2=ChangeInHighMinus_2/TrailingStdMinus_2\n",
    "LowDifferentialMinus_2=ChangeInLowMinus_2/TrailingStdMinus_2\n",
    "\n",
    "MomentumMinus_2=(LowDifferentialMinus_2-HighDifferentialMinus_2)\n",
    "data['Momentum%Minus_2']=MomentumMinus_2/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5925af5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 3 day tenor (T=3)\n",
    "\n",
    "ChangeInHighMinus_3=data.high.shift(+150)/data.close.shift(+4)\n",
    "ChangeInLowMinus_3=data.close.shift(+4)/data.low.shift(+150)\n",
    "TrailingStdMinus_3=data.close.shift(+4).rolling(60).std()/data.close.shift(+4).rolling(60).mean()\n",
    "HighDifferentialMinus_3=ChangeInHighMinus_3/TrailingStdMinus_3\n",
    "LowDifferentialMinus_3=ChangeInLowMinus_3/TrailingStdMinus_3\n",
    "\n",
    "MomentumMinus_3=(LowDifferentialMinus_3-HighDifferentialMinus_3)\n",
    "data['Momentum%Minus_3']=MomentumMinus_3/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1db08463",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 4 day tenor (T=4)\n",
    "\n",
    "ChangeInHighMinus_4=data.high.shift(+180)/data.close.shift(+5)\n",
    "ChangeInLowMinus_4=data.close.shift(+5)/data.low.shift(+180)\n",
    "TrailingStdMinus_4=data.close.shift(+5).rolling(60).std()/data.close.shift(+5).rolling(60).mean()\n",
    "HighDifferentialMinus_4=ChangeInHighMinus_4/TrailingStdMinus_4\n",
    "LowDifferentialMinus_4=ChangeInLowMinus_4/TrailingStdMinus_4\n",
    "\n",
    "MomentumMinus_4=(LowDifferentialMinus_4-HighDifferentialMinus_4)\n",
    "data['Momentum%Minus_4']=MomentumMinus_4/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d76146d5",
   "metadata": {},
   "outputs": [],
   "source": [
    "#DOWNLOAD_DIR1 = \"C:/Users/mary jane/Downloads/\"\n",
    "#filename1 = \"BTC_17_21.csv\"\n",
    "#data= pd.read_csv(DOWNLOAD_DIR1+filename1)\n",
    "#data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "982481cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=data.iloc[:,:13]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "701fffaf",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from matplotlib import pyplot as plt\n",
    "from statsmodels.tsa.holtwinters import ExponentialSmoothing as HWES"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "627e3dbb",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import pandas as pd\n",
    "from matplotlib import pyplot as plt\n",
    "from statsmodels.tsa.holtwinters import SimpleExpSmoothing  as HWES\n",
    "from tqdm import tqdm\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "tqdm.pandas()\n",
    "%matplotlib inline\n",
    "import time\n",
    "import pylab as pl\n",
    "from IPython import display\n",
    "import math\n",
    "\n",
    "\n",
    "df_train = pd.DataFrame()\n",
    "MAE=0\n",
    "i=0\n",
    "for i in tqdm(range(len(data))):\n",
    "    df_train =data['close'].iloc[0:i]\n",
    "    def mean_absolute_error(Y_actual,Y_Predicted):\n",
    "        mape = np.mean(np.abs((Y_actual - Y_Predicted)/Y_actual))\n",
    "        return mape\n",
    "    \n",
    "    if i <1000:\n",
    "        pass\n",
    "    else:\n",
    "        if i==1000:\n",
    "            model = HWES(df_train).fit()\n",
    "            forecast_2hr=np.array(model.forecast(60)[1:2])\n",
    "            MAE=np.array((1*(mean_absolute_error(data['close'][1001:i+2],forecast_2hr[0:i])/data['close'][1001:i+2].mean())))\n",
    "            \n",
    "         \n",
    "        else:\n",
    "            last_forecast=forecast_2hr[-1]\n",
    "            df_train =data['close'].iloc[i-1000:i]\n",
    "            model = HWES(df_train).fit()\n",
    "            \n",
    "            if np.isnan(model.forecast(60)[59:].values)==True:\n",
    "                forecast_2hr=np.append(forecast_2hr,last_forecast)\n",
    "            else:\n",
    "                \n",
    "                    forecast_2hr=np.append(forecast_2hr,model.forecast(60)[1:2]) \n",
    "            #if i <1012:\n",
    "                #MAE=np.append(MAE,((1*(mean_absolute_error(data['close'][1001:i+2],forecast_2hr[0:i])/data['close'][1001:i+2].mean()))))\n",
    "            #else:\n",
    "                #MAE=np.append(MAE,((1*(mean_absolute_error(data['close'][(i+2)-12:i+2],forecast_2hr[i-12-1000:i-1000])/data['close'][(i+2)-12:i+2].mean()))))\n",
    "\n",
    "\n",
    "\n",
    "            #if i % 500 == 0:\n",
    "                #try:\n",
    "                    #plt.plot(MAE)\n",
    "                    #display.display(plt.show())\n",
    "                    #display.clear_output(wait=True)\n",
    "                    \n",
    "                #except KeyboardInterrupt:\n",
    "                    #break\n",
    "\n",
    "            \n",
    "\n",
    "                  \n",
    "            \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2049da92",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "naive=pd.DataFrame(forecast_2hr)\n",
    "\n",
    "naive"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a521688a",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=data[1000:]\n",
    "data=data.reset_index()\n",
    "data=data.drop('index',axis=1)\n",
    "\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "640c3995",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=data.merge(naive,left_index=True,right_index=True)\n",
    "data=data.dropna()\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dd518a22",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=data.drop('date', axis=1)\n",
    "data.to_csv('BTC_17_21.csv',index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "780a21a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "DOWNLOAD_DIR1 = \"C:/Users/mary jane/Downloads/\"\n",
    "filename1 = \"BTC_17_21.csv\"\n",
    "data= pd.read_csv(DOWNLOAD_DIR1+filename1)\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8a62ebb0",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=data.dropna()\n",
    "cols = data.columns\n",
    "data=data[cols].apply(lambda row: ','.join(row.values.astype(str)), axis=1)\n",
    "\n",
    "data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "160a2021",
   "metadata": {},
   "outputs": [],
   "source": [
    "import ast\n",
    "\n",
    "test=pd.DataFrame(data)\n",
    "test=test[0].apply(ast.literal_eval)\n",
    "test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "042ce927",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "from collections import deque"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "470a037a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "from collections import deque\n",
    "\n",
    "def formatPrice(n):\n",
    "    return(\"-Rs.\" if n<0 else \"Rs.\")+list(map('{:.2f}%'.format,n))\n",
    "\n",
    "def sigmoid(x):\n",
    "    return 1/(1+np.exp(-x))\n",
    "def getState(data, t, n):\n",
    "    d = t - n + 1\n",
    "    data=pd.DataFrame(data)\n",
    "    data=data[0].apply(ast.literal_eval)\n",
    "    data=list(data)\n",
    "    block = data[d:t + 1] if d >= 0 else -d * [data[0]] + data[0:t + 1] # pad with t0\n",
    "    res = []\n",
    "    for i in range(n - 1):\n",
    "        array1 = np.array(block[i])\n",
    "        array2 = np.array(block[i + 1])\n",
    "        res.append(sigmoid(np.subtract(array2, array1)))\n",
    "    \n",
    "    return np.array([res])\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4e40902f",
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.layers import BatchNormalization\n",
    "\n",
    "class Agent:    \n",
    "    def __init__(self, state_size, is_eval=False, model_name=\"\"):\n",
    "            self.state_size = state_size # normalized previous days\n",
    "            self.action_size = 4 # hold, buy,buy all,  sell all\n",
    "            self.memory = deque(maxlen=720)\n",
    "            self.NAV=[]\n",
    "            self.inventory = []\n",
    "            self.action_list=[]\n",
    "            self.model_name = model_name\n",
    "            self.is_eval = is_eval\n",
    "            self.gamma = 0.95\n",
    "            self.epsilon = .25\n",
    "            self.epsilon_min = 0.01\n",
    "            self.epsilon_decay = 0.995\n",
    "            self.model = tf.keras.models.load_model(model_name) if is_eval else self._model()\n",
    "            \n",
    "    def _model(self):\n",
    "        model = tf.keras.models.Sequential()\n",
    "        model.add(tf.keras.layers.GRU(50, return_sequences=True))\n",
    "        model.add(tf.keras.layers.GRU(30, return_sequences=True))\n",
    "        model.add(tf.keras.layers.GRU(20, return_sequences=True))\n",
    "        model.add(tf.keras.layers.GRU(10))\n",
    "        model.add(keras.layers.Dense(4, activation='softmax'))\n",
    "        model.compile(loss=\"sparse_categorical_crossentropy\", optimizer=keras.optimizers.Adam(learning_rate=0.05))\n",
    "        return model\n",
    "    def act(self, state):\n",
    "        if not self.is_eval and random.random()<= self.epsilon:\n",
    "            return random.randrange(self.action_size)\n",
    "        \n",
    "        options = self.model.predict(np.array(state))\n",
    "        return np.argmax(options[0])\n",
    "    def expReplay(self, batch_size):\n",
    "        mini_batch = []\n",
    "        l = len(self.memory)\n",
    "        for i in range(l - batch_size + 1, l):\n",
    "            mini_batch.append(self.memory[i])\n",
    "        for state, action, reward, next_state, done in mini_batch:\n",
    "            target = reward\n",
    "            if not done:\n",
    "                target = reward + self.gamma * np.amax(self.model.predict(next_state)[0])\n",
    "            target_f = self.model.predict(state)\n",
    "            target_f[0][action] = target\n",
    "            self.model.fit(state, target_f,epochs=5, verbose=0)\n",
    "        if self.epsilon > self.epsilon_min:\n",
    "            self.epsilon *= self.epsilon_decay\n",
    "    def buy(self, initial_money):\n",
    "        starting_money = initial_money\n",
    "        states_sell = []\n",
    "        states_buy = []\n",
    "        inventory = []\n",
    "        state = self.getState(0)\n",
    "        for t in range(0, len(self.trend) - 1, self.skip):\n",
    "            action = self.act(state)\n",
    "            next_state = self.getState(t + 1)\n",
    "            if action == 1 and initial_money >= self.trend[t] and t < (len(self.trend) - self.half_window):\n",
    "                inventory.append(self.trend[t])\n",
    "                initial_money -= self.trend[t]\n",
    "                states_buy.append(t)\n",
    "                print('day %d: buy 1 unit at price %f, total balance %f'% (t, self.trend[t], initial_money))\n",
    "            elif action == 2 and len(inventory):\n",
    "                bought_price = inventory.pop(0)\n",
    "                initial_money += self.trend[t]\n",
    "                states_sell.append(t)\n",
    "                try:\n",
    "                    invest = ((close[t] - bought_price) / bought_price) * 100\n",
    "                except:\n",
    "                    invest = 0\n",
    "                print(\n",
    "                    'day %d, sell 1 unit at price %f, investment %f %%, total balance %f,'\n",
    "                    % (t, close[t], invest, initial_money)\n",
    "                )\n",
    "            state = next_state\n",
    "        invest = ((initial_money - starting_money) / starting_money) * 100\n",
    "        total_gains = initial_money - starting_money\n",
    "        return states_buy, states_sell, total_gains, invest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "32a6c124",
   "metadata": {},
   "outputs": [],
   "source": [
    "test=list(test)\n",
    "btc = [item[3] for item in test]\n",
    "btc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a4ba1b53",
   "metadata": {},
   "outputs": [],
   "source": [
    "data=np.array(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "12ca15a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "from tqdm import tqdm\n",
    "import time\n",
    "batch_size = (10000)\n",
    "stock_name = \"BTC\"\n",
    "window_size = 60*24\n",
    "episode_count = 5\n",
    "stock_name = str(stock_name)\n",
    "window_size = int(window_size)\n",
    "episode_count = int(episode_count)\n",
    "trend=btc\n",
    "agent = Agent(window_size)\n",
    "%matplotlib inline\n",
    "l = len(data) - 1\n",
    "\n",
    "\n",
    "np.random.seed(42)\n",
    "tf.random.set_seed(42)\n",
    "keras.backend.clear_session()\n",
    "for e in range(episode_count + 1):\n",
    "    print(\"Episode \" + str(e) + \"/\" + str(episode_count))\n",
    "    state = getState(data, 0, window_size + 1)\n",
    "    total_profit = 0\n",
    "    NAV=(btc[0]*10)\n",
    "    Liquidity=(btc[0]*10)\n",
    "    buyallPrice=btc[0]\n",
    "    LiquidityAll=0\n",
    "    inventory=0\n",
    "    agent.inventory = []\n",
    "    NAV_Series=np.array((((NAV)/(btc[0]*10)))/(((btc[0])/btc[0])))\n",
    "    Block_Price=btc[0]\n",
    "    \n",
    "    \n",
    "   \n",
    "    \n",
    "   \n",
    "    for t in tqdm(range(l)):\n",
    "        \n",
    "        \n",
    "        \n",
    "        action = agent.act(np.array(state))\n",
    "        price=btc[t]\n",
    "\n",
    "        \n",
    "        if t==0:\n",
    "            Liquidity=price*10\n",
    "            Block_Liquidity=Liquidity\n",
    "            \n",
    "        elif t>=1:\n",
    "            Liquidity=((btc[0]*10)-sum(agent.inventory)+total_profit)\n",
    "        if btc[t]>=Liquidity:\n",
    "            action = 0 or 3\n",
    "        \n",
    "        # sit\n",
    "        next_state = getState(data, t + 1, window_size + 1)\n",
    "        reward = 0\n",
    "        \n",
    "        \n",
    "        if action == 1: # buy\n",
    "            \n",
    "            agent.inventory.append(btc[t])\n",
    "            inventory=len(agent.inventory)\n",
    "            Liquidity=Liquidity-(agent.inventory[-1])\n",
    "            NAV=sum(agent.inventory)+Liquidity\n",
    "            \n",
    "\n",
    "            \n",
    "        \n",
    "            \n",
    "            \n",
    "        elif action == 2: # buy all\n",
    "            \n",
    "            buyingPower=math.trunc(Liquidity/price)\n",
    "            Block_Price=btc[t]\n",
    "            Block_Liquidity=Liquidity\n",
    "            agent.inventory.append(Block_Price*buyingPower)\n",
    "            Liquidity=Liquidity-(Block_Price*buyingPower)\n",
    "            \n",
    "            NAV=sum(agent.inventory)+Liquidity\n",
    "            \n",
    "            \n",
    "            \n",
    "            \n",
    "        elif action == 3: \n",
    "            while sum(agent.inventory) >0 and len(agent.inventory)>0: # sell all\n",
    "                if agent.memory[-1]!=2 or(agent.memory[-1]!=2 and agent.memory[-2]!=2) or(agent.memory[-1]!=2 and agent.memory[-2]!=2 and agent.memory[-3]!=2 ) and t>3:\n",
    "                    Block_Shares_Owned=0\n",
    "                else:\n",
    "                    Block_Shares_Owned=math.trunc(Block_Liquidity/Block_Price)\n",
    "                if Block_Shares_Owned!=0:\n",
    "                    bought_price =  sum(agent.inventory)/(len(agent.inventory)+Block_Shares_Owned-1)\n",
    "                else:\n",
    "                    bought_price =  sum(agent.inventory)/(len(agent.inventory))\n",
    "                if ((btc[t] - bought_price)*(buyingPower+inventory))<0:\n",
    "                    total_profit += ((btc[t] - bought_price)*(buyingPower+inventory))\n",
    "                else:\n",
    "                    total_profit += ((btc[t] - bought_price)*(buyingPower+inventory)*(1-.37))\n",
    "                \n",
    "               \n",
    "                agent.inventory=[]\n",
    "                Block_Shares_Owned=0\n",
    "                inventory=0\n",
    "                buyingPower=0\n",
    "                bought_price=0\n",
    "                buyallPrice=btc[t]\n",
    "                LiquidityAll=Liquidity\n",
    "                NAV=(btc[0]*10)+total_profit\n",
    "                Liquidity=NAV-sum(agent.inventory)\n",
    "                \n",
    "        elif action ==0:\n",
    "            while sum(agent.inventory)>0 and t>0:\n",
    "                if agent.memory[-1]!=2 or(agent.memory[-1]!=2 and agent.memory[-2]!=2) or(agent.memory[-1]!=2 and agent.memory[-2]!=2 and agent.memory[-3]!=2 ) and t>3:\n",
    "                    Block_Shares_Owned=0\n",
    "                else:\n",
    "                    Block_Shares_Owned=math.trunc(Block_Liquidity/Block_Price)\n",
    "                if Block_Shares_Owned!=0:\n",
    "                    bought_price =  sum(agent.inventory)/(len(agent.inventory)+Block_Shares_Owned-1)\n",
    "                else:\n",
    "                    bought_price =  sum(agent.inventory)/(len(agent.inventory))\n",
    "                NAV=sum(agent.inventory)+((btc[t] - bought_price)*(buyingPower+inventory))+Liquidity\n",
    "                \n",
    "\n",
    "        \n",
    "    \n",
    "        \n",
    "\n",
    "        NAV_Series=np.append(NAV_Series,(((NAV)/(btc[0]*10)))/(((btc[t])/btc[0])))\n",
    "        \n",
    "        reward = max((((((NAV)/(btc[0]*10)))/(((price)/btc[0])))-1), 0)\n",
    "        \n",
    "\n",
    "        \n",
    "\n",
    "                     \n",
    "                \n",
    "        done = True if t == l - 1 else False\n",
    "        \n",
    "        agent.memory.append((action))\n",
    "        state = next_state\n",
    "        \n",
    "            \n",
    "       \n",
    "\n",
    "        if done:\n",
    "            print(\"--------------------------------\")\n",
    "            print(str(t)+\" | \"+\"Price: \" + str(price)+\" Total Profit: \"+str(total_profit)+\" | Inventory: \" + str(sum(agent.inventory))+\" \" + str(len(agent.inventory))+\" | Liquidity: \" + str(Liquidity)+\" | Alpha: \"+str((((NAV/(btc[0]*10))/(btc[t]/btc[0])))))\n",
    "            print(\"--------------------------------\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ec9ee71",
   "metadata": {},
   "outputs": [],
   "source": [
    "agent.model.save('BTC_AgentModel.h5')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "673e3660",
   "metadata": {},
   "outputs": [],
   "source": [
    "from datetime import datetime\n",
    "from time import time, sleep\n",
    "\n",
    "start = datetime(2022,1,1)\n",
    "\n",
    "client = MyRESTClient(['xz0v5qmSd2ZFCW1Q8A4rOIsIWtk5cht2'])\n",
    "df2 = client.get_bars(market='crypto', ticker='X:BTCUSD', from_=start)\n",
    "df2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c2ebd25",
   "metadata": {},
   "outputs": [],
   "source": [
    "df2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "73bb3ca1",
   "metadata": {},
   "outputs": [],
   "source": [
    "data2=df2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ebafbf05",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Calculate the MACD and Signal Line indicators\n",
    "## Calculate the Short Term Exponential Moving Average\n",
    "ShortEMA = data2.close.ewm(span=1440, adjust=False).mean() \n",
    "## Calculate the Long Term Exponential Moving Average\n",
    "LongEMA = data2.close.ewm(span=43200, adjust=False).mean() \n",
    "## Calculate the Moving Average Convergence/Divergence (MACD)\n",
    "data2['MACD'] = ShortEMA - LongEMA\n",
    "## Calcualte the signal line\n",
    "data2['signal'] = data2['MACD'].ewm(span=9, adjust=False).mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5eea345",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at t=0 day tenor\n",
    "\n",
    "ChangeInHigh=data2.high.shift(+25)/data2.close.shift(+1)\n",
    "ChangeInLow=data2.close.shift(+1)/data2.low.shift(+25)\n",
    "TrailingStd=data2.close.shift(+1).rolling(24).std()/data2.close.shift(+1).rolling(24).mean()\n",
    "HighDifferential=ChangeInHigh/TrailingStd\n",
    "LowDifferential=ChangeInLow/TrailingStd\n",
    "\n",
    "Momentum=(LowDifferential-HighDifferential)\n",
    "data2['Momentum%']=Momentum/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f1895b9b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 1 day tenor (T=1)\n",
    "\n",
    "ChangeInHighMinus_1=data2.high.shift(+26)/data2.close.shift(+2)\n",
    "ChangeInLowMinus_1=data2.close.shift(+2)/data2.low.shift(+26)\n",
    "TrailingStdMinus_1=data2.close.shift(+2).rolling(24).std()/data2.close.shift(+2).rolling(24).mean()\n",
    "HighDifferentialMinus_1=ChangeInHighMinus_1/TrailingStdMinus_1\n",
    "LowDifferentialMinus_1=ChangeInLowMinus_1/TrailingStdMinus_1\n",
    "\n",
    "MomentumMinus_1=(LowDifferentialMinus_1-HighDifferentialMinus_1)\n",
    "data2['Momentum%Minus_1']=Momentum/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b8ebb03c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 2 day tenor (T=2)\n",
    "\n",
    "ChangeInHighMinus_2=data2.high.shift(+27)/data2.close.shift(+3)\n",
    "ChangeInLowMinus_2=data2.close.shift(+3)/data2.low.shift(+27)\n",
    "TrailingStdMinus_2=data2.close.shift(+3).rolling(24).std()/data2.close.shift(+3).rolling(24).mean()\n",
    "HighDifferentialMinus_2=ChangeInHighMinus_2/TrailingStdMinus_2\n",
    "LowDifferentialMinus_2=ChangeInLowMinus_2/TrailingStdMinus_2\n",
    "\n",
    "MomentumMinus_2=(LowDifferentialMinus_2-HighDifferentialMinus_2)\n",
    "data2['Momentum%Minus_2']=MomentumMinus_2/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bff14336",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 3 day tenor (T=3)\n",
    "\n",
    "ChangeInHighMinus_3=data2.high.shift(+28)/data2.close.shift(+4)\n",
    "ChangeInLowMinus_3=data2.close.shift(+4)/data2.low.shift(+28)\n",
    "TrailingStdMinus_3=data2.close.shift(+4).rolling(24).std()/data2.close.shift(+4).rolling(24).mean()\n",
    "HighDifferentialMinus_3=ChangeInHighMinus_3/TrailingStdMinus_3\n",
    "LowDifferentialMinus_3=ChangeInLowMinus_3/TrailingStdMinus_3\n",
    "\n",
    "MomentumMinus_3=(LowDifferentialMinus_3-HighDifferentialMinus_3)\n",
    "data2['Momentum%Minus_3']=MomentumMinus_3/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "39e7aabb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from statistics import median\n",
    "\n",
    "#classical momentum gauge at 4 day tenor (T=4)\n",
    "\n",
    "ChangeInHighMinus_4=data2.high.shift(+29)/data2.close.shift(+5)\n",
    "ChangeInLowMinus_4=data2.close.shift(+5)/data2.low.shift(+29)\n",
    "TrailingStdMinus_4=data2.close.shift(+5).rolling(24).std()/data2.close.shift(+5).rolling(24).mean()\n",
    "HighDifferentialMinus_4=ChangeInHighMinus_4/TrailingStdMinus_4\n",
    "LowDifferentialMinus_4=ChangeInLowMinus_4/TrailingStdMinus_4\n",
    "\n",
    "MomentumMinus_4=(LowDifferentialMinus_4-HighDifferentialMinus_4)\n",
    "data2['Momentum%Minus_4']=MomentumMinus_4/100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "95bcb894",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from matplotlib import pyplot as plt\n",
    "from statsmodels.tsa.holtwinters import ExponentialSmoothing as HWES\n",
    "from tqdm import tqdm\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "tqdm.pandas()\n",
    "\n",
    "\n",
    "df_train = pd.DataFrame()\n",
    "\n",
    "i=0\n",
    "for i in tqdm(range(5016)):\n",
    "    if i <100:\n",
    "        pass\n",
    "    else:\n",
    "        if i==100:\n",
    "            df_train =data2['close'].iloc[0:i]\n",
    "            model = HWES(df_train, seasonal_periods=24, trend='mul', seasonal='mul').fit()\n",
    "            forecast_1hr=model.forecast(1)\n",
    "         \n",
    "        else:\n",
    "            df_train =data2['close'].iloc[i-100:i]\n",
    "            model = HWES(df_train, seasonal_periods=24, trend='mul', seasonal='mul').fit()\n",
    "            forecast_1hr=np.append(forecast_1hr,model.forecast(1))\n",
    "\n",
    "\n",
    "forecast_1hr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cad43702",
   "metadata": {},
   "outputs": [],
   "source": [
    "naive=pd.DataFrame(forecast_1hr)\n",
    "naive"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b0b36743",
   "metadata": {},
   "outputs": [],
   "source": [
    "data2=data2[100:]\n",
    "data2=data2.reset_index()\n",
    "data2=data2.drop('index',axis=1)\n",
    "data2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "026ef798",
   "metadata": {},
   "outputs": [],
   "source": [
    "data2=data2.merge(naive,left_index=True,right_index=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2b2cf90f",
   "metadata": {},
   "outputs": [],
   "source": [
    "data2.to_csv('BTC22.csv',index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6d2c620",
   "metadata": {},
   "outputs": [],
   "source": [
    "DOWNLOAD_DIR1 = \"C:/Users/mary jane/Downloads/\"\n",
    "filename1 = \"BTC22.csv\"\n",
    "data2= pd.read_csv(DOWNLOAD_DIR1+filename1)\n",
    "data2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "915e5e08",
   "metadata": {},
   "outputs": [],
   "source": [
    "def formatPrice(n):\n",
    "    return(\"-Rs.\" if n<0 else \"Rs.\")+list(map('{:.2f}%'.format,n))\n",
    "def getStockDataVec(key):\n",
    "    vec = []\n",
    "    lines = open(\"BTC22.csv\",\"r\").read().splitlines()\n",
    "    for line in lines[1:]:\n",
    "        #print(line)\n",
    "        #print(float(line.split(\",\")[4]))\n",
    "        vec.append([float(vec) for vec in line.split(',')[1:]])\n",
    "        \n",
    "        #print(vec)\n",
    "    return vec\n",
    "def sigmoid(x):\n",
    "    return 1/(1+np.exp(-x))\n",
    "def getState(data, t, n):\n",
    "    d = t - n + 1\n",
    "    block = data[d:t + 1] if d >= 0 else -d * [data[0]] + data[0:t + 1] # pad with t0\n",
    "    res = []\n",
    "    for i in range(n - 1):\n",
    "        array1 = np.array(block[i])\n",
    "        array2 = np.array(block[i + 1])\n",
    "        res.append(sigmoid(np.subtract(array2, array1)))\n",
    "    return np.array([res])\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7bc48363",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "data2 = getStockDataVec(stock_name)\n",
    "data2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "99ee040b",
   "metadata": {},
   "outputs": [],
   "source": [
    "btc = [item[3] for item in data2]\n",
    "btc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41e6db33",
   "metadata": {},
   "outputs": [],
   "source": [
    "def flatten(lists):\n",
    "    results = []\n",
    "    for numbers in lists:\n",
    "        for x in numbers:\n",
    "            results.append(x)\n",
    "    return results\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7dba8a7c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.layers import BatchNormalization\n",
    "\n",
    "class Agent:    \n",
    "    def __init__(self, state_size, is_eval=False, model_name=\"\"):\n",
    "            self.state_size = state_size # normalized previous days\n",
    "            self.action_size = 4 # hold, buy,buy all,  sell all\n",
    "            self.memory = deque(maxlen=6000)\n",
    "            \n",
    "            self.inventory = []\n",
    "            self.action_list=[]\n",
    "            self.model_name = model_name\n",
    "            self.is_eval = is_eval\n",
    "            self.gamma = 0.95\n",
    "            self.epsilon = .25\n",
    "            self.epsilon_min = 0.01\n",
    "            self.epsilon_decay = 0.995\n",
    "            self.model = tf.keras.models.load_model(model_name) if is_eval else self._model()\n",
    "            \n",
    "    def _model(self):\n",
    "        model = keras.models.Sequential()\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(units=1200, activation=\"relu\"))\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(units=600, activation=\"relu\"))\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(units=300, activation=\"relu\"))\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(units=150, activation=\"relu\"))\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(units=75, activation=\"relu\"))\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(units=25, activation=\"relu\"))\n",
    "        model.add(keras.layers.BatchNormalization())\n",
    "        model.add(keras.layers.Dense(self.action_size, activation=\"linear\"))\n",
    "        model.compile(loss=\"mse\", optimizer=keras.optimizers.Adam(learning_rate=0.001))\n",
    "        return model\n",
    "    def act(self, state):\n",
    "        if not self.is_eval and random.random()<= self.epsilon:\n",
    "            return random.randrange(self.action_size)\n",
    "        options = self.model.predict(np.array(state))\n",
    "        return np.argmax(options[0])\n",
    "    def expReplay(self, batch_size):\n",
    "        mini_batch = []\n",
    "        l = len(self.memory)\n",
    "        for i in range(l - batch_size + 1, l):\n",
    "            mini_batch.append(self.memory[i])\n",
    "        for state, action, reward, next_state, done in mini_batch:\n",
    "            target = reward\n",
    "            if not done:\n",
    "                target = reward + self.gamma * np.amax(self.model.predict(next_state)[0])\n",
    "            target_f = self.model.predict(state)\n",
    "            target_f[0][action] = target\n",
    "            self.model.fit(state, target_f,epochs=5, verbose=0)\n",
    "        if self.epsilon > self.epsilon_min:\n",
    "            self.epsilon *= self.epsilon_decay\n",
    "    def buy(self, initial_money):\n",
    "        starting_money = initial_money\n",
    "        states_sell = []\n",
    "        states_buy = []\n",
    "        inventory = []\n",
    "        state = self.getState(0)\n",
    "        for t in range(0, len(self.trend) - 1, self.skip):\n",
    "            action = self.act(state)\n",
    "            next_state = self.getState(t + 1)\n",
    "            if action == 1 and initial_money >= self.trend[t] and t < (len(self.trend) - self.half_window):\n",
    "                inventory.append(self.trend[t])\n",
    "                initial_money -= self.trend[t]\n",
    "                states_buy.append(t)\n",
    "                print('day %d: buy 1 unit at price %f, total balance %f'% (t, self.trend[t], initial_money))\n",
    "            elif action == 2 and len(inventory):\n",
    "                bought_price = inventory.pop(0)\n",
    "                initial_money += self.trend[t]\n",
    "                states_sell.append(t)\n",
    "                try:\n",
    "                    invest = ((close[t] - bought_price) / bought_price) * 100\n",
    "                except:\n",
    "                    invest = 0\n",
    "                print(\n",
    "                    'day %d, sell 1 unit at price %f, investment %f %%, total balance %f,'\n",
    "                    % (t, close[t], invest, initial_money)\n",
    "                )\n",
    "            state = next_state\n",
    "        invest = ((initial_money - starting_money) / starting_money) * 100\n",
    "        total_gains = initial_money - starting_money\n",
    "        return states_buy, states_sell, total_gains, invest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4bc38868",
   "metadata": {},
   "outputs": [],
   "source": [
    "stock_name = input(\"Enter Stock_name\")\n",
    "model_name = 'BTC_AgentModel.h5'\n",
    "model = tf.keras.models.load_model(model_name)\n",
    "window_size = model.layers[0].input.shape.as_list()[1]\n",
    "agent = Agent(window_size, True, model_name)\n",
    "\n",
    "\n",
    "batch_size = 10000\n",
    "np.random.seed(42)\n",
    "tf.random.set_seed(42)\n",
    "keras.backend.clear_session()\n",
    "l=len(data2)-1\n",
    "print(state)\n",
    "state = getState(data2, 0, window_size + 1)\n",
    "total_profit = 0\n",
    "buyallPrice=btc[t]\n",
    "LiquidityAll=0\n",
    "invenotry=0\n",
    "agent.inventory = []\n",
    "NAV=(btc[0]*10)\n",
    "for t in range(l):\n",
    "        \n",
    "        action = agent.act(np.array(state))\n",
    "        price=btc[t]\n",
    "        \n",
    "        if t==0:\n",
    "            Liquidity=price*10\n",
    "            buyingPower=[Liquidity/btc[t]]\n",
    "        elif t>=1:\n",
    "            Liquidity=((btc[0]*10)-sum(agent.inventory)+total_profit)\n",
    "        if btc[t]>=Liquidity:\n",
    "            action = 0 or 3\n",
    "        # sit\n",
    "        next_state = getState(data2, t + 1, window_size + 1)\n",
    "        reward = 0\n",
    "        \n",
    "        \n",
    "        if action == 1: # buy\n",
    "            NAV=(btc[0]*10)+total_profit\n",
    "            agent.inventory.append(btc[t])\n",
    "            inventory=len(agent.inventory)\n",
    "            \n",
    "            Liquidity=((btc[0]*10)+total_profit-sum(agent.inventory))\n",
    "        \n",
    "            \n",
    "            print(\"Buy \"+str(price)+\"------\"+str(Liquidity)+\"------\"+str(sum(agent.inventory))+\"------\"+str(len(agent.inventory)))\n",
    "        \n",
    "        elif action == 2: # buy all\n",
    "            NAV=(btc[0]*10)+total_profit\n",
    "            buyingPower.append(math.trunc(Liquidity/price))\n",
    "            Block_Price=btc[t]\n",
    "            Block_Liquidity=Liquidity\n",
    "            agent.inventory.append(Block_Price*buyingPower[-1])\n",
    "            \n",
    "            Liquidity=((btc[0]*10)+total_profit-sum(agent.inventory))\n",
    "            \n",
    "            print(\"Buy All \"+str(price)+\"------\"+str(Liquidity)+\"------\"+str(sum(agent.inventory))+\"------\"+str(len(agent.inventory)))\n",
    "    \n",
    "            \n",
    "        elif action == 3: \n",
    "            while len(agent.inventory) >0 and Liquidity<price: # sell all\n",
    "                Block_Shares_Owned=Block_Liquidity/Block_Price\n",
    "                bought_price =  sum(agent.inventory)/(Block_Shares_Owned+len(agent.inventory)-1)\n",
    "                if (btc[t] - bought_price)*(Block_Shares_Owned+inventory)<0: \n",
    "                    total_profit = total_profit+(btc[t] - bought_price)*(Block_Shares_Owned+inventory)\n",
    "                else:\n",
    "                    total_profit = total_profit+(btc[t] - bought_price)*(Block_Shares_Owned+inventory)*(1-.37)\n",
    "                Liquidity=(Liquidity+total_profit)\n",
    "               \n",
    "                agent.inventory=[]\n",
    "                Block_Shares_Owned=0\n",
    "                inventory=0\n",
    "                buyallPrice=btc[t]\n",
    "                LiquidityAll=Liquidity\n",
    "                NAV=(btc[0]*10)+total_profit\n",
    "                \n",
    "                print(\"Sell All \"+\"------\"+str(price)+\"-----> \"+str(total_profit)+\"---------\"+str((((total_profit+(btc[0]*10))/(btc[0]*10))/(price/46412.24)))+\"--------\"+str(len(agent.inventory)))\n",
    "        elif action ==0:\n",
    "            NAV=(btc[0]*10)+total_profit\n",
    "            print(\"Hold \"+str(price)+\"------\"+str(Liquidity)+\"------\"+str(sum(agent.inventory))+\"------\"+str(len(agent.inventory)))\n",
    "            continue\n",
    "                \n",
    "            \n",
    "\n",
    "        reward = max(total_profit*(((((total_profit+(btc[0]*10))/(btc[0]*10)))/(((price)/46412.24)))-1), 0)\n",
    "        done = True if t == l - 1 else False\n",
    "        agent.memory.append((price,NAV,action))\n",
    "        state = next_state\n",
    "        if done:\n",
    "            print(\"--------------------------------\")\n",
    "            print(\"Price: \" + str(price)+\" Total Profit: \"+str(total_profit)+\" | Inventory: \" + str(sum(agent.inventory))+\" \" + str(len(agent.inventory))+\" | Liquidity: \" + str(Liquidity)+\" | Alpha: \"+str((((total_profit+(btc[0]*10))/(btc[0]*10))/(price/46412.24))))\n",
    "            print(\"--------------------------------\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6211959c",
   "metadata": {},
   "outputs": [],
   "source": [
    "agent.memory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4587b0d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "len(agent.memory)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "522d2d9b",
   "metadata": {},
   "outputs": [],
   "source": [
    "Performance=pd.DataFrame([item for item in agent.memory])\n",
    "Performance.columns=['price','NAV','action']\n",
    "Performance.loc[Performance['action'] > 3.5, 'action'] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e4b7a0f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "Performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "03dc5428",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "Performance['NAV_']=(Performance['NAV']/10)\n",
    "\n",
    "fig = plt.figure(figsize = (300,100))\n",
    "plt.plot(Performance['price'], color='y', lw=2.)\n",
    "plt.plot(Performance['NAV_'], color='b', lw=10,label = 'NAV')\n",
    "plt.plot(Performance['price'], '-', markersize=20, color='g', label = 'action', markevery = 0)\n",
    "plt.plot(Performance['price'], 'o', markersize=20, color='k', label = 'action', markevery = 1)\n",
    "plt.plot(Performance['price'], 'o', markersize=20, color='k', label = 'action', markevery = 2)\n",
    "plt.plot(Performance['price'], 'v', markersize=20, color='r', label = 'action', markevery = 3)\n",
    "plt.title('total gains %f, total investment return %f%%'%(773797.979572-463040.100000,773797.979572/464122.400000))\n",
    "plt.legend()\n",
    "plt.savefig('.png')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41852842",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
